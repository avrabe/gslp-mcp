package adas:can-gateway@0.1.0;

/// CAN/CAN-FD gateway for automotive network communication
interface can-gateway {
    /// CAN network configuration
    record can-config {
        network-id: u32,
        bus-type: bus-type,
        baudrate: u32,
        data-baudrate: option<u32>,  // For CAN-FD
        sample-point: f32,
        synchronization-jump-width: u32,
        enable-error-frames: bool,
        enable-remote-frames: bool,
        loopback-mode: bool,
        listen-only-mode: bool,
    }

    enum bus-type {
        can-classic,
        can-fd,
        can-xl,
        automotive-ethernet,
        flexray,
        lin,
    }

    /// CAN message structure
    record can-message {
        message-id: u32,
        extended-id: bool,
        data: list<u8>,
        data-length: u8,
        timestamp: u64,
        bus-id: u32,
        message-type: message-type,
        priority: message-priority,
        error-flags: list<error-flag>,
    }

    enum message-type {
        data-frame,
        remote-frame,
        error-frame,
        overload-frame,
        heartbeat,
        diagnostic,
        configuration,
        status,
    }

    enum message-priority {
        highest,
        high,
        normal,
        low,
        lowest,
        background,
    }

    enum error-flag {
        none,
        bit-error,
        stuff-error,
        crc-error,
        form-error,
        ack-error,
        bus-off,
        error-passive,
        arbitration-lost,
        overrun,
        timeout,
    }

    /// Gateway routing configuration
    record routing-config {
        routing-rules: list<routing-rule>,
        message-filters: list<message-filter>,
        translation-rules: list<translation-rule>,
        security-policies: list<security-policy>,
        quality-of-service: qos-settings,
    }

    record routing-rule {
        rule-id: u32,
        source-network: u32,
        destination-networks: list<u32>,
        message-id-range: id-range,
        action: routing-action,
        conditions: list<routing-condition>,
        priority: u32,
    }

    record id-range {
        start-id: u32,
        end-id: u32,
        mask: option<u32>,
    }

    enum routing-action {
        forward,
        block,
        transform,
        duplicate,
        aggregate,
        delay,
        prioritize,
    }

    record routing-condition {
        condition-type: condition-type,
        parameter: string,
        operator: comparison-operator,
        value: string,
    }

    enum condition-type {
        message-rate,
        payload-content,
        source-node,
        time-window,
        error-count,
        bus-load,
        authentication,
        encryption,
    }

    enum comparison-operator {
        equals,
        not-equals,
        greater-than,
        less-than,
        contains,
        regex-match,
    }

    record message-filter {
        filter-id: u32,
        filter-type: filter-type,
        criteria: filter-criteria,
        action: filter-action,
        enabled: bool,
    }

    enum filter-type {
        whitelist,
        blacklist,
        rate-limit,
        content-filter,
        security-filter,
        diagnostic-filter,
    }

    record filter-criteria {
        message-ids: list<u32>,
        source-nodes: list<string>,
        payload-patterns: list<string>,
        rate-threshold: option<f32>,
        content-rules: list<content-rule>,
    }

    record content-rule {
        byte-offset: u32,
        byte-mask: u8,
        expected-value: u8,
        comparison: comparison-operator,
    }

    enum filter-action {
        allow,
        deny,
        throttle,
        log,
        alert,
        quarantine,
    }

    record translation-rule {
        rule-id: u32,
        source-format: message-format,
        target-format: message-format,
        id-translation: id-translation,
        data-transformation: data-transformation,
        header-mapping: header-mapping,
    }

    enum message-format {
        can-classic,
        can-fd,
        automotive-ethernet,
        some-ip,
        doip,
        uds,
        j1939,
        obd2,
    }

    record id-translation {
        source-id: u32,
        target-id: u32,
        id-mapping-type: id-mapping-type,
        offset: option<u32>,
        scale: option<f32>,
    }

    enum id-mapping-type {
        direct,
        offset,
        lookup-table,
        algorithmic,
        dynamic,
    }

    record data-transformation {
        transformation-type: transformation-type,
        byte-operations: list<byte-operation>,
        endian-conversion: bool,
        scaling-factor: option<f32>,
        offset-value: option<f32>,
    }

    enum transformation-type {
        none,
        byte-swap,
        bit-manipulation,
        scaling,
        lookup-table,
        custom-function,
    }

    record byte-operation {
        operation-type: operation-type,
        source-offset: u32,
        target-offset: u32,
        length: u32,
        parameter: option<u32>,
    }

    enum operation-type {
        copy,
        invert,
        mask,
        shift-left,
        shift-right,
        xor,
        checksum,
    }

    record header-mapping {
        preserve-timestamp: bool,
        preserve-priority: bool,
        preserve-error-flags: bool,
        add-routing-info: bool,
        add-security-header: bool,
    }

    record security-policy {
        policy-id: u32,
        security-level: security-level,
        authentication: authentication-config,
        encryption: encryption-config,
        access-control: access-control-config,
        intrusion-detection: intrusion-detection-config,
    }

    enum security-level {
        none,
        basic,
        standard,
        high,
        critical,
    }

    record authentication-config {
        enabled: bool,
        method: auth-method,
        key-management: key-management,
        certificate-validation: bool,
        replay-protection: bool,
    }

    enum auth-method {
        none,
        hmac,
        digital-signature,
        pki,
        symmetric-key,
        asymmetric-key,
    }

    record key-management {
        key-rotation-interval: u32,
        key-derivation-function: string,
        secure-key-storage: bool,
        key-escrow: bool,
    }

    record encryption-config {
        enabled: bool,
        algorithm: encryption-algorithm,
        key-length: u32,
        mode: encryption-mode,
        compression: bool,
    }

    enum encryption-algorithm {
        none,
        aes,
        des,
        rsa,
        ecc,
        chacha20,
    }

    enum encryption-mode {
        ecb,
        cbc,
        cfb,
        ofb,
        gcm,
        ccm,
    }

    record access-control-config {
        enable-acl: bool,
        default-policy: access-policy,
        node-permissions: list<node-permission>,
        time-based-access: bool,
        rate-limiting: bool,
    }

    enum access-policy {
        allow-all,
        deny-all,
        whitelist,
        blacklist,
    }

    record node-permission {
        node-id: string,
        allowed-messages: list<u32>,
        allowed-operations: list<operation-permission>,
        access-level: access-level,
        time-restrictions: list<time-restriction>,
    }

    enum operation-permission {
        read,
        write,
        execute,
        configure,
        diagnose,
        update,
    }

    enum access-level {
        guest,
        user,
        operator,
        administrator,
        security-officer,
    }

    record time-restriction {
        start-time: u32,
        end-time: u32,
        days-of-week: list<day-of-week>,
        timezone: string,
    }

    enum day-of-week {
        monday,
        tuesday,
        wednesday,
        thursday,
        friday,
        saturday,
        sunday,
    }

    record intrusion-detection-config {
        enabled: bool,
        detection-methods: list<detection-method>,
        alert-thresholds: alert-thresholds,
        response-actions: list<response-action>,
        logging-level: logging-level,
    }

    enum detection-method {
        anomaly-detection,
        signature-based,
        behavioral-analysis,
        statistical-analysis,
        machine-learning,
        rule-based,
    }

    record alert-thresholds {
        error-rate-threshold: f32,
        message-rate-threshold: f32,
        anomaly-score-threshold: f32,
        failed-auth-threshold: u32,
        time-window: u32,
    }

    enum response-action {
        log-only,
        alert,
        block-source,
        isolate-network,
        emergency-shutdown,
        notify-security,
    }

    enum logging-level {
        none,
        error,
        warning,
        info,
        debug,
        trace,
    }

    record qos-settings {
        bandwidth-allocation: list<bandwidth-allocation>,
        latency-requirements: list<latency-requirement>,
        reliability-settings: reliability-settings,
        congestion-control: congestion-control,
    }

    record bandwidth-allocation {
        network-id: u32,
        guaranteed-bandwidth: f32,
        maximum-bandwidth: f32,
        priority-level: u32,
        burst-allowance: f32,
    }

    record latency-requirement {
        message-class: message-class,
        max-latency: f32,
        jitter-tolerance: f32,
        deadline-miss-action: deadline-action,
    }

    enum message-class {
        safety-critical,
        real-time,
        high-priority,
        normal,
        best-effort,
        background,
    }

    enum deadline-action {
        drop-message,
        log-warning,
        alert,
        fallback-route,
        emergency-action,
    }

    record reliability-settings {
        retransmission-enabled: bool,
        max-retries: u32,
        acknowledgment-required: bool,
        duplicate-detection: bool,
        error-correction: bool,
    }

    record congestion-control {
        algorithm: congestion-algorithm,
        threshold-utilization: f32,
        backoff-strategy: backoff-strategy,
        queue-management: queue-management,
    }

    enum congestion-algorithm {
        token-bucket,
        leaky-bucket,
        sliding-window,
        adaptive,
        priority-based,
    }

    enum backoff-strategy {
        linear,
        exponential,
        random,
        adaptive,
        priority-aware,
    }

    record queue-management {
        queue-size: u32,
        drop-policy: drop-policy,
        scheduling-algorithm: scheduling-algorithm,
        priority-queues: u32,
    }

    enum drop-policy {
        drop-tail,
        drop-head,
        random-drop,
        priority-drop,
        aging-drop,
    }

    enum scheduling-algorithm {
        fifo,
        priority,
        round-robin,
        weighted-round-robin,
        earliest-deadline-first,
    }

    /// Network monitoring and diagnostics
    record network-statistics {
        bus-statistics: list<bus-statistics>,
        message-statistics: message-statistics,
        error-statistics: error-statistics,
        performance-metrics: performance-metrics,
        security-events: list<security-event>,
    }

    record bus-statistics {
        bus-id: u32,
        utilization: f32,
        message-count: u64,
        error-count: u64,
        active-nodes: u32,
        average-latency: f32,
        peak-latency: f32,
    }

    record message-statistics {
        total-messages: u64,
        messages-forwarded: u64,
        messages-blocked: u64,
        messages-transformed: u64,
        messages-dropped: u64,
        duplicate-messages: u64,
    }

    record error-statistics {
        total-errors: u64,
        crc-errors: u64,
        framing-errors: u64,
        overrun-errors: u64,
        timeout-errors: u64,
        authentication-failures: u64,
    }

    record performance-metrics {
        throughput: f32,
        latency-percentiles: list<latency-percentile>,
        cpu-utilization: f32,
        memory-utilization: f32,
        queue-depths: list<u32>,
    }

    record latency-percentile {
        percentile: f32,
        latency: f32,
    }

    record security-event {
        event-id: u32,
        event-type: security-event-type,
        severity: security-severity,
        source-node: string,
        timestamp: u64,
        description: string,
        mitigation-action: option<string>,
    }

    enum security-event-type {
        unauthorized-access,
        authentication-failure,
        encryption-failure,
        intrusion-detected,
        dos-attack,
        replay-attack,
        message-tampering,
        certificate-invalid,
    }

    enum security-severity {
        info,
        low,
        medium,
        high,
        critical,
    }

    enum gateway-status {
        offline,
        initializing,
        active,
        degraded,
        error,
        maintenance,
    }

    /// Initialize CAN gateway
    initialize: func(networks: list<can-config>, routing: routing-config) -> result<_, string>;

    /// Start gateway operation
    start-gateway: func() -> result<_, string>;

    /// Stop gateway operation
    stop-gateway: func() -> result<_, string>;

    /// Send CAN message
    send-message: func(message: can-message, target-networks: list<u32>) -> result<_, string>;

    /// Receive CAN messages
    receive-messages: func(network-id: u32, timeout: u32) -> result<list<can-message>, string>;

    /// Configure message routing
    configure-routing: func(routing: routing-config) -> result<_, string>;

    /// Update security policies
    update-security: func(policies: list<security-policy>) -> result<_, string>;

    /// Get network statistics
    get-statistics: func() -> result<network-statistics, string>;

    /// Configure network QoS
    configure-qos: func(qos: qos-settings) -> result<_, string>;

    /// Add network interface
    add-network: func(config: can-config) -> result<u32, string>;

    /// Remove network interface
    remove-network: func(network-id: u32) -> result<_, string>;

    /// Get gateway status
    get-status: func() -> gateway-status;

    /// Run network diagnostic
    run-diagnostic: func(network-id: option<u32>) -> result<diagnostic-result, string>;

    record diagnostic-result {
        network-health: list<network-health>,
        routing-test: routing-test-result,
        security-test: security-test-result,
        performance-test: performance-test-result,
        compliance-check: compliance-check-result,
    }

    record network-health {
        network-id: u32,
        connectivity: bool,
        signal-quality: f32,
        error-rate: f32,
        node-count: u32,
        bus-utilization: f32,
    }

    record routing-test-result {
        rules-tested: u32,
        rules-passed: u32,
        latency-test: test-result,
        throughput-test: test-result,
        filtering-test: test-result,
    }

    enum test-result {
        passed,
        failed,
        warning,
        not-applicable,
        timeout,
    }

    record security-test-result {
        authentication-test: test-result,
        encryption-test: test-result,
        access-control-test: test-result,
        intrusion-detection-test: test-result,
        vulnerability-scan: vulnerability-scan-result,
    }

    record vulnerability-scan-result {
        vulnerabilities-found: u32,
        critical-vulnerabilities: u32,
        security-score: f32,
        recommendations: list<string>,
    }

    record performance-test-result {
        max-throughput: f32,
        min-latency: f32,
        max-latency: f32,
        packet-loss: f32,
        stress-test-result: test-result,
    }

    record compliance-check-result {
        iso11898-compliant: bool,
        sae-j1939-compliant: bool,
        autosar-compliant: bool,
        iso26262-compliant: bool,
        compliance-score: f32,
    }
}

world can-gateway-component {
    export can-gateway;
}