/// Pipeline Orchestrator - Controls execution flow and scheduling of ADAS components
package adas:pipeline-orchestrator@0.1.0;

world pipeline-orchestrator-component {
    /// Export orchestrator control interface
    export orchestrator: interface {
        /// Execution modes for different use cases
        enum execution-mode {
            real-time,        // Process frames as fast as possible
            fixed-rate,       // Process at fixed FPS (e.g., 30 FPS)
            on-demand,        // Process only when explicitly triggered
            batch-processing, // Process all frames in sequence
        }

        /// Processing priority levels
        enum priority-level {
            critical,  // Safety-critical processing (emergency braking)
            high,      // Normal driving assistance (lane keeping)
            normal,    // Comfort features (adaptive cruise)
            low,       // Background processing (diagnostics)
        }

        /// Component execution state
        enum component-state {
            idle,
            ready,
            processing,
            waiting,
            error,
            disabled,
        }

        /// Pipeline stage definition
        record pipeline-stage {
            component-id: string,
            input-buffers: list<string>,
            output-buffers: list<string>,
            execution-time-budget-ms: u32,
            priority: priority-level,
            enabled: bool,
        }

        /// Buffer configuration
        record buffer-config {
            name: string,
            max-size: u32,
            overflow-policy: overflow-policy,
            data-type: string,
        }

        enum overflow-policy {
            drop-oldest,   // Drop oldest data when buffer full
            drop-newest,   // Drop newest data when buffer full
            block-producer, // Block producer until space available
        }

        /// Orchestrator configuration
        record orchestrator-config {
            execution-mode: execution-mode,
            target-fps: f32,
            max-processing-time-ms: u32,
            enable-backpressure: bool,
            enable-load-balancing: bool,
            pipeline-stages: list<pipeline-stage>,
            buffers: list<buffer-config>,
        }

        /// Runtime metrics
        record orchestrator-metrics {
            current-fps: f32,
            avg-frame-latency-ms: f64,
            buffer-utilization: list<f32>,
            component-states: list<component-state>,
            dropped-frames: u32,
            total-processed: u32,
        }

        /// Orchestrator control functions
        configure-pipeline: func(config: orchestrator-config) -> result<_, string>;
        start-orchestrator: func() -> result<_, string>;
        stop-orchestrator: func() -> result<_, string>;
        pause-orchestrator: func() -> result<_, string>;
        resume-orchestrator: func() -> result<_, string>;
        
        /// Execution control
        execute-single-cycle: func() -> result<string, string>;
        execute-n-cycles: func(count: u32) -> result<string, string>;
        execute-for-duration: func(duration-ms: u32) -> result<string, string>;
        
        /// Buffer management
        get-buffer-status: func(buffer-name: string) -> result<string, string>;
        flush-buffer: func(buffer-name: string) -> result<_, string>;
        resize-buffer: func(buffer-name: string, new-size: u32) -> result<_, string>;
        
        /// Component control
        enable-component: func(component-id: string) -> result<_, string>;
        disable-component: func(component-id: string) -> result<_, string>;
        set-component-priority: func(component-id: string, priority: priority-level) -> result<_, string>;
        
        /// Monitoring and diagnostics
        get-metrics: func() -> orchestrator-metrics;
        get-component-state: func(component-id: string) -> result<component-state, string>;
        run-diagnostics: func() -> result<string, string>;
    }

    /// Export frame buffer interface for data flow control
    export frame-buffer: interface {
        /// Frame data with metadata
        record frame-data {
            id: u64,
            timestamp: u64,
            priority: priority-level,
            data: list<u8>,
            width: u32,
            height: u32,
            format: string,
            source-component: string,
        }

        /// Detection data with metadata
        record detection-data {
            frame-id: u64,
            timestamp: u64,
            detections: list<u8>, // Serialized detection results
            processing-time-ms: f64,
            confidence-threshold: f32,
            source-component: string,
        }

        /// Buffer operations
        push-frame: func(buffer-name: string, frame: frame-data) -> result<_, string>;
        pop-frame: func(buffer-name: string) -> result<frame-data, string>;
        peek-frame: func(buffer-name: string) -> result<frame-data, string>;
        
        push-detection: func(buffer-name: string, detection: detection-data) -> result<_, string>;
        pop-detection: func(buffer-name: string) -> result<detection-data, string>;
        
        /// Buffer status
        get-buffer-size: func(buffer-name: string) -> result<u32, string>;
        is-buffer-full: func(buffer-name: string) -> result<bool, string>;
        is-buffer-empty: func(buffer-name: string) -> result<bool, string>;
    }

    /// Export scheduling interface for time-based control
    export scheduler: interface {
        /// Scheduling policies
        enum scheduling-policy {
            round-robin,    // Equal time slices for all components
            priority-based, // Higher priority components get more time
            deadline-driven, // Components with deadlines get priority
            load-balanced,  // Distribute load based on component capacity
        }

        /// Task definition for scheduler
        record scheduled-task {
            component-id: string,
            execution-interval-ms: u32,
            deadline-ms: u32,
            max-execution-time-ms: u32,
            priority: priority-level,
            enabled: bool,
        }

        /// Scheduler configuration
        record scheduler-config {
            policy: scheduling-policy,
            time-slice-ms: u32,
            enable-preemption: bool,
            tasks: list<scheduled-task>,
        }

        /// Scheduler control
        configure-scheduler: func(config: scheduler-config) -> result<_, string>;
        add-task: func(task: scheduled-task) -> result<_, string>;
        remove-task: func(component-id: string) -> result<_, string>;
        modify-task: func(component-id: string, task: scheduled-task) -> result<_, string>;
        
        /// Execution control
        tick: func() -> result<list<string>, string>; // Execute one scheduler cycle
        get-next-task: func() -> result<string, string>;
        
        /// Monitoring
        get-task-status: func(component-id: string) -> result<string, string>;
        get-scheduler-metrics: func() -> result<string, string>;
    }
}